const e="940beb37",t="="+e,r="-"+e,n=t+"-ws",s=r+"-ws",{create:a}=Object;let o="coincident-",c=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),o+=crypto.randomUUID()}catch(e){c=!1,o+=Math.random().toString(36).substring(2)}const l=2*Int32Array.BYTES_PER_ELEMENT,i={byteOffset:l,useUTF16:!0,circular:!0},u=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n},{fromCharCode:f}=String,{min:y}=Math;var p=e=>({byteOffset:t=0}={})=>(r,n)=>{const s=new Uint16Array(n,t,r);let a="",o=0;for(;o<r;){const e=y(o+32767,r);a+=f.apply(null,s.subarray(o,e)),o=e}return e(a)};const{parse:d}=JSON,g=p(d),w="array",h="bigint",b="boolean",m="function",v="null",P="number",E="object",O="string",S="symbol",T="undefined";var x={[w]:0,[h]:1,[b]:2,[m]:3,[v]:4,[P]:5,[E]:6,[O]:7,[S]:8,[T]:9,view:10};const{parse:R}=JSON,_=p((e=>{const t=R(e);switch(t[0]){case x.view:{const[e,r]=t[1],n=new Uint8Array(r);t[1]=new globalThis[e](n.buffer);break}case x[T]:t[1]=void 0;break;case x[h]:t[1]=BigInt(t[1])}return t})),A=Promise.withResolvers.bind(Promise);const k=[],M=new WeakSet,I=(...e)=>(M.add(e),e),B=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),B.resolve([e.data,e.ports[0]])}),{once:!0});var N=async e=>{const[t,r]=await B.promise,n=c&&!!t,s=e?.transform,o=(e?.decoder||g)(i),l=!1!==e?.transfer;let f,y,p;if(c){const t=new SharedArrayBuffer(e?.minByteLength||32767,{maxByteLength:e?.maxByteLength||16777216});f=new Int32Array(t),({pause:y,wait:p}=Atomics),!y||n||t instanceof ArrayBuffer||(p=(e,t)=>{for(;e[t]<1;)y()})}const[d,w]=((e=e=>e)=>{const t=new Map;let r=0;return[()=>{let n;do{n=e(r++)}while(t.has(n));const s=A();return t.set(n,s),[n,s.promise]},(e,r,n)=>{const s=t.get(e);t.delete(e),n?s?.reject(n):s?.resolve(r)}]})(String),h=new Map,b=a(null),m=new Proxy(b,{get(e,a){if("then"===a)return;let i=h.get(a);return i||h.set(a,i=(...e)=>{const i=((e,t)=>{let r=k;return e&&M.has(t.at(-1)||k)&&(r=t.pop(),M.delete(r)),r})(l,e),u=[f,a,s?e.map(s):e];if(c){n?postMessage({ID:t,data:u},i):r.postMessage(u,i),p(f,0),f[0]=0;const e=f[1]?o(f[1],f.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=d();return u[0]=e,r.postMessage(u,i),t}}),i},set:u});return r.onmessage=async({data:e})=>{"string"==typeof e[0]?w.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,b,s),r.postMessage(e))},{native:c,proxy:m,transfer:I}};const L="apply",j="construct",Y="defineProperty",D="deleteProperty",F="get",U="getOwnPropertyDescriptor",W="getPrototypeOf",C="has",$="isExtensible",K="ownKeys",G="preventExtensions",z="set",J="setPrototypeOf";var V=Object.freeze({__proto__:null,APPLY:L,CONSTRUCT:j,DEFINE_PROPERTY:Y,DELETE_PROPERTY:D,GET:F,GET_OWN_PROPERTY_DESCRIPTOR:U,GET_PROTOTYPE_OF:W,HAS:C,IS_EXTENSIBLE:$,OWN_KEYS:K,PREVENT_EXTENSION:G,SET:z,SET_PROTOTYPE_OF:J});const X="destruct";function H(){return this}const q=new FinalizationRegistry((([e,t,r])=>{r&&console.debug(`%c${String(t)}`,"font-weight:bold","collected"),e(t)})),Q=Object.create(null),{Object:Z,Proxy:ee,Reflect:te}=globalThis,{isArray:re}=Array,{ownKeys:ne}=te,{create:se,hasOwn:ae,values:oe}=Z,ce=(e,t)=>t===w?e[0]:t===m?e():t===E?e.$:e,le=(e,t,r,n)=>{const s={type:{value:t}},a=ae(e,"valueOf");for(const o of oe(V)){let c=n(e[o]||te[o]);if(a&&o===F){const{valueOf:n}=e,{value:s}=c;c={value(e,a,...o){return a===r?n.call(this,ce(e,t)):s.call(this,e,a,...o)}}}s[o]=c}return se(e,s)},ie=(e,t,r,n=e)=>{if(n===e)switch(typeof e){case E:case T:n||(n=!1);case m:break;default:n=!1,t===e&&(t=Z(e))}const s=new ee(t,r),{destruct:a}=r;return a?((e,t,{debug:r,handler:n,return:s,token:a=e}=Q)=>{const o=s||new Proxy(e,n||Q),c=[o,[t,e,!!r]];return!1!==a&&c.push(a),q.register(...c),o})(e,a,{token:n,return:s}):s},ue=e=>t=>{const r=typeof t;return r===E?t?e.get(t)?.[0]??(e=>re(e)?w:E)(t):v:r},fe=e=>t=>{let r=typeof t;switch(r){case E:if(!t){r=v;break}case m:const n=e.get(t);n&&([r,t]=n)}return[r,t]},ye=e=>((e=>{q.unregister(e)})(e),e);var pe=e=>{const t=new WeakMap,r=Symbol(),n={},s=(e,r,n)=>(t.set(e,[r,n]),e),a={proxy:n,release:ye,pair:fe(t),typeOf:ue(t),isProxy:e=>t.has(e),valueOf:e=>e[r]??e.valueOf()};for(const t of ne(e)){if(ae(a,t))continue;const o=e[t];switch(t){case w:{const e=le(o,t,r,(e=>({value([t],...r){return e.call(this,t,...r)}})));n[t]=(t,...r)=>s(ie(t,[t],e,...r),w,t);break}case m:{const e=le(o,t,r,(e=>({value(t,...r){return e.call(this,t(),...r)}})));n[t]=(t,...r)=>{return s(ie(t,(n=t,H.bind(n)),e,...r),m,t);var n};break}case E:{const e=le(o,t,r,(e=>({value({$:t},...r){return e.call(this,t,...r)}})));n[t]=(t,...r)=>s(ie(t,{$:t},e,...r),E,t);break}default:{const e=le(o,t,r,(e=>({value:e})));n[t]=(r,...n)=>s(ie(r,r,e,...n),t,r);break}}}return a};const{drop:de,get:ge,hold:we}=(()=>{const e=new Map,t=new Map;let r=0;return{clear:()=>{e.clear(),t.clear()},drop:r=>{const[n,s]=typeof r===P?[t,e]:[e,t],a=n.has(r);return a&&(s.delete(n.get(r)),n.delete(r)),a},get:e=>t.get(e),hold:n=>{if(!e.has(n)){let s;for(;t.has(s=r++););e.set(n,s),t.set(s,n)}return e.get(n)}}})(),he=new Map;for(const e of Reflect.ownKeys(Symbol))typeof Symbol[e]===S&&(he.set(Symbol[e],e),he.set(e,Symbol[e]));const be=e=>he.get(e)||`.${Symbol.keyFor(e)||""}`,{isArray:me}=Array,{isView:ve}=ArrayBuffer,{[L]:Pe}=Reflect;var Ee=(e,t)=>{const r=new Map,n=(e,t)=>{let n=r.get(e)?.deref();return n||r.set(e,new WeakRef(n=t(e))),n},s=([e,t])=>{switch(e){case x[E]:return null==t?globalThis:typeof t===P?n(t,i.object):t;case x[w]:return typeof t===P?n(t,i.array):t;case x[m]:return typeof t===P?n(t,i.function):ge(parseInt(t));case x[S]:return(e=>he.get(e)||Symbol.for(e.slice(1)))(t);default:return t}},a=e=>{let[r,n]=f(e);switch(r){case E:if(n==globalThis||null==n)n=null;else if(typeof n===E){if(n=t(n),me(n))return[x[w],n.map(a)];if(ve(n))return[x.view,n];{const e={};for(const t in n)e[t]=a(n[t]);n=e}}return[x[E],n];case w:return[x[w],typeof n===P?n:t(n).map(a)];case m:return[x[m],typeof n===m?String(we(t(n))):n];case S:return[x[S],be(e)];default:return[x[r],n]}},o=(...t)=>s(e(...t)),c={[Y]:(e,t,r)=>o(Y,e,a(t),a(r)),[D]:(e,t)=>o(D,e,a(t)),[F]:(e,t)=>o(F,e,a(t)),[W]:e=>o(W,e),[U]:(e,t)=>{const r=o(U,e,a(t));if(r){const{get:e,set:t,value:n}=r;e&&(r.get=s(e)),t&&(r.set=s(t)),n&&(r.value=s(n))}return r},[C]:(e,t)=>o(C,e,a(t)),[$]:e=>o($,e),[K]:e=>o(K,e).map(s),[G]:e=>o(G,e),[z]:(e,t,r)=>o(z,e,a(t),a(r)),[J]:(e,t)=>o(J,e,a(t)),[X](t){r.delete(t),e(X,t)}},l={[E]:c,[w]:c,[m]:{...c,[L]:(e,...t)=>o(L,e,...t.map(a)),[j]:(e,...t)=>o(j,e,...t.map(a))}},{proxy:i,isProxy:u,pair:f}=pe(l);return{isProxy:u,global:i.object(null),method:async(e,t,...r)=>{const n=parseInt(t);switch(e){case L:{const[e,t]=r;return a(await Pe(ge(n),s(e),t.map(s)))}case X:de(n)}}}},Oe=async e=>{let n=!1;const s=e?.decoder||g,a=await N({...e,decoder(e){const t=s(e),r=_(e);return(e,s)=>n?(n=!1,r(e,s)):t(e,s)}}),o=a.proxy[t],{isProxy:c,global:l,method:i}=Ee((function(...e){return n=!0,o.apply(this,e)}),e?.transform||(e=>e));return a.proxy[r]=i,{...a,window:l,isWindowProxy:c}},Se=async e=>{const t=await Oe(e),{isProxy:r,global:a,method:o}=Ee(t.proxy[n],e?.transform||(e=>e));return t.proxy[s]=o,{...t,server:a,isServerProxy:r}};export{Se as default};
