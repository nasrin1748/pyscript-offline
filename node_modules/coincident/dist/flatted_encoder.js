var e={ref:0,array:1,object:2,number:3,string:4,true:5,false:6,null:7,buffer:8,view:9,symbol:10,date:11,bigint:12,undefined:13,map:14,set:15,regexp:16,error:17};let t="coincident-";try{new SharedArrayBuffer(4,{maxByteLength:8}),t+=crypto.randomUUID()}catch(e){t+=Math.random().toString(36).substring(2)}const{getPrototypeOf:r}=Object,s=e=>{const t=typeof e;switch(t){case"function":case"undefined":return"";case"object":return null===e?"null":"object";default:return t}},{isArray:n}=Array,{isView:a}=ArrayBuffer,{stringify:o}=JSON,c=(t,r,s)=>{const n=r.get(s);return"number"==typeof n?(t.push(e.ref,n),!0):(r.set(s,t.length),!1)},f=(t,o,u,i=s(u))=>{switch(i){case"null":t.push(e.null);break;case"object":if(c(t,o,u))break;switch(!0){case n(u):{const r=u.length;t.push(e.array,r);for(let e=0;e<r;e++)f(t,o,u[e]);break}case a(u):{const{BYTES_PER_ELEMENT:s,buffer:n,byteOffset:a,length:f}=u;if(t.push(e.view,(e=>{for(;!(e.name in globalThis);)e=r(e);return e.name})(u.constructor),a,f!==(n.byteLength-a)/s?f:0),c(t,o,n))break;u=n}case u instanceof ArrayBuffer:{const r=u.byteLength,s=u.resizable?u.maxByteLength:0;if(t.push(e.buffer,r,s),r){const e=new Uint8Array(u,0,r);for(let r=0;r<e.length;r+=32767)t.push.apply(t,e.subarray(r,r+32767))}break}case u instanceof Date:t.push(e.date,+u);break;case u instanceof Map:{const r=t.push(e.map,0);let n=0;for(const[e,r]of u){const a=s(e),c=s(r);a&&c&&(f(t,o,e,a),f(t,o,r,c),n++)}t[r-1]=n;break}case u instanceof Set:{const r=t.push(e.set,0);let n=0;for(const e of u){const r=s(e);r&&(f(t,o,e,r),n++)}t[r-1]=n;break}case u instanceof RegExp:t.push(e.regexp,u.source,u.flags);break;case u instanceof Error:t.push(e.error,u.name,u.message,u.stack,u.cause);break;default:{if("toJSON"in u){const r=u.toJSON();if(r===u){t.push(e.object,0);break}if(c(t,o,u=r))break}const r=t.push(e.object,0);let n=0;for(const e in u){const r=u[e],a=s(r);a&&(f(t,o,e,"string"),f(t,o,r,a),n++)}t[r-1]=n;break}}break;case"boolean":t.push(u?e.true:e.false);break;case"string":if(c(t,o,u))break;t.push(e.string,u);break;case"bigint":t.push(e.bigint,u.toString());break;case"symbol":{const r=(e=>{const t=String(e).slice(7,-1);return t.startsWith("Symbol.")||Symbol.keyFor(e)?t:""})(u);if(r){t.push(e.symbol,r);break}}case"":t.push(e.undefined);break;default:t.push(e[i],u)}},u=e=>{const t=[];return f(t,new Map,e),t},i=e=>o(u(e)),b=(e=>({byteOffset:t=0}={})=>(r,s)=>{const n=e(r),a=n.length,o=2*a+t;s.byteLength<o&&s.grow(o);const c=new Uint16Array(s,t,a);for(let e=0;e<a;e++)c[e]=n.charCodeAt(e);return a})(i);export{i as encode,b as encoder,u as raw};
