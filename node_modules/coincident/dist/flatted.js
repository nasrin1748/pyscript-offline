const{getPrototypeOf:e}=Object,r=e=>{const r=typeof e;switch(r){case"function":case"undefined":return"";case"object":return null===e?"null":"object";default:return r}};let t="coincident-";try{new SharedArrayBuffer(4,{maxByteLength:8}),t+=crypto.randomUUID()}catch(e){t+=Math.random().toString(36).substring(2)}var n={ref:0,array:1,object:2,number:3,string:4,true:5,false:6,null:7,buffer:8,view:9,symbol:10,date:11,bigint:12,undefined:13,map:14,set:15,regexp:16,error:17};const{defineProperty:s}=Object,a=e=>{switch(e[c++]){case n.array:{const r=e[c++],t=[];e[c-2]=t;for(let n=0;n<r;n++)t[n]=a(e);return t}case n.object:{const r=e[c++],t={};e[c-2]=t;for(let n=0;n<r;n++)t[a(e)]=a(e);return t}case n.string:{const r=e[c++];return e[c-2]=r,r}case n.number:return e[c++];case n.true:return!0;case n.false:return!1;case n.null:return null;case n.undefined:return;case n.bigint:return BigInt(e[c++]);case n.buffer:{const r=e[c++],t=e[c++],n=[r];t&&n.push({maxByteLength:t});const s=new ArrayBuffer(...n);e[c-3]=s;const a=new Uint8Array(s,0,r);for(let t=0;t<r;t++)a[t]=e[c++];return s}case n.view:{const r=e[c++],t=e[c++],n=e[c++],s=c-4,o=[a(e),t];n&&o.push(n);const u=new globalThis[r](...o);return e[s]=u,u}case n.date:{const r=new Date(e[c++]);return e[c-2]=r,r}case n.map:{const r=e[c++],t=new Map;e[c-2]=t;for(let n=0;n<r;n++){const r=a(e),n=a(e);void 0!==r&&t.set(r,n)}return t}case n.set:{const r=e[c++],t=new Set;e[c-2]=t;for(let n=0;n<r;n++){const r=a(e);void 0!==r&&t.add(r)}return t}case n.regexp:{const r=e[c++],t=e[c++],n=new RegExp(r,t);return e[c-3]=n,n}case n.error:{const r=globalThis[e[c++]]||Error,t=e[c++],n=e[c++],a=new r(t,{cause:e[c++]});return e[c-5]=s(a,"stack",{value:n}),a}case n.symbol:return(r=e[c++]).startsWith("Symbol.")?Symbol[r.slice(r.indexOf(".")+1)]:Symbol.for(r);case n.ref:return e[e[c++]];default:throw new TypeError(`Unknown type: ${e[c-1]}`)}var r},{parse:o}=JSON;let c=0;const u=e=>{return r=o(e),c=0,r.length?a(r):void 0;var r},{isArray:i}=Array,{isView:f}=ArrayBuffer,{stringify:l}=JSON,b=(e,r,t)=>{const s=r.get(t);return"number"==typeof s?(e.push(n.ref,s),!0):(r.set(t,e.length),!1)},h=(t,s,a,o=r(a))=>{switch(o){case"null":t.push(n.null);break;case"object":if(b(t,s,a))break;switch(!0){case i(a):{const e=a.length;t.push(n.array,e);for(let r=0;r<e;r++)h(t,s,a[r]);break}case f(a):{const{BYTES_PER_ELEMENT:r,buffer:o,byteOffset:c,length:u}=a;if(t.push(n.view,(r=>{for(;!(r.name in globalThis);)r=e(r);return r.name})(a.constructor),c,u!==(o.byteLength-c)/r?u:0),b(t,s,o))break;a=o}case a instanceof ArrayBuffer:{const e=a.byteLength,r=a.resizable?a.maxByteLength:0;if(t.push(n.buffer,e,r),e){const r=new Uint8Array(a,0,e);for(let e=0;e<r.length;e+=32767)t.push.apply(t,r.subarray(e,e+32767))}break}case a instanceof Date:t.push(n.date,+a);break;case a instanceof Map:{const e=t.push(n.map,0);let o=0;for(const[e,n]of a){const a=r(e),c=r(n);a&&c&&(h(t,s,e,a),h(t,s,n,c),o++)}t[e-1]=o;break}case a instanceof Set:{const e=t.push(n.set,0);let o=0;for(const e of a){const n=r(e);n&&(h(t,s,e,n),o++)}t[e-1]=o;break}case a instanceof RegExp:t.push(n.regexp,a.source,a.flags);break;case a instanceof Error:t.push(n.error,a.name,a.message,a.stack,a.cause);break;default:{if("toJSON"in a){const e=a.toJSON();if(e===a){t.push(n.object,0);break}if(b(t,s,a=e))break}const e=t.push(n.object,0);let o=0;for(const e in a){const n=a[e],c=r(n);c&&(h(t,s,e,"string"),h(t,s,n,c),o++)}t[e-1]=o;break}}break;case"boolean":t.push(a?n.true:n.false);break;case"string":if(b(t,s,a))break;t.push(n.string,a);break;case"bigint":t.push(n.bigint,a.toString());break;case"symbol":{const e=(e=>{const r=String(e).slice(7,-1);return r.startsWith("Symbol.")||Symbol.keyFor(e)?r:""})(a);if(e){t.push(n.symbol,e);break}}case"":t.push(n.undefined);break;default:t.push(n[o],a)}},p=e=>l((e=>{const r=[];return h(r,new Map,e),r})(e));export{u as decode,p as encode};
