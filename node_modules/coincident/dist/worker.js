const e=Promise.withResolvers.bind(Promise);const{create:t}=Object;let r="coincident-",n=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),r+=crypto.randomUUID()}catch(e){n=!1,r+=Math.random().toString(36).substring(2)}const a=2*Int32Array.BYTES_PER_ELEMENT,s={byteOffset:a,useUTF16:!0,circular:!0},o=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n},{fromCharCode:c}=String,{min:i}=Math;const{parse:l}=JSON,f=(p=l,({byteOffset:e=0}={})=>(t,r)=>{const n=new Uint16Array(r,e,t);let a="",s=0;for(;s<t;){const e=i(s+32767,t);a+=c.apply(null,n.subarray(s,e)),s=e}return p(a)});var p;const u=[],y=new WeakSet,d=(...e)=>(y.add(e),e),m=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),m.resolve([e.data,e.ports[0]])}),{once:!0});var g=async r=>{const[a,c]=await m.promise,i=n&&!!a,l=r?.transform,p=(r?.decoder||f)(s),g=!1!==r?.transfer;let h,w,v;if(n){const e=new SharedArrayBuffer(r?.minByteLength||32767,{maxByteLength:r?.maxByteLength||16777216});h=new Int32Array(e),({pause:w,wait:v}=Atomics),!w||i||e instanceof ArrayBuffer||(v=(e,t)=>{for(;e[t]<1;)w()})}const[M,B]=((t=e=>e)=>{const r=new Map;let n=0;return[()=>{let a;do{a=t(n++)}while(r.has(a));const s=e();return r.set(a,s),[a,s.promise]},(e,t,n)=>{const a=r.get(e);r.delete(e),n?a?.reject(n):a?.resolve(t)}]})(String),S=new Map,b=t(null),A=new Proxy(b,{get(e,t){if("then"===t)return;let r=S.get(t);return r||S.set(t,r=(...e)=>{const r=((e,t)=>{let r=u;return e&&y.has(t.at(-1)||u)&&(r=t.pop(),y.delete(r)),r})(g,e),s=[h,t,l?e.map(l):e];if(n){i?postMessage({ID:a,data:s},r):c.postMessage(s,r),v(h,0),h[0]=0;const e=h[1]?p(h[1],h.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=M();return s[0]=e,c.postMessage(s,r),t}}),r},set:o});return c.onmessage=async({data:e})=>{"string"==typeof e[0]?B.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,b,l),c.postMessage(e))},{native:n,proxy:A,transfer:d}};export{g as default};
