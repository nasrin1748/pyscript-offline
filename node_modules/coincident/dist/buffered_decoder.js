let t="coincident-";try{new SharedArrayBuffer(4,{maxByteLength:8}),t+=crypto.randomUUID()}catch(e){t+=Math.random().toString(36).substring(2)}var e=256===new DataView(new Uint16Array([256]).buffer).getUint16(0,!0),n=0,r=1,s=2,c=3,a=4,o=5,u=10,i=20,l=30,f=40,g=50,w=51,y=52,h=53,U=54,b=55,d=64,p=70,m=100,S=101,A=102,x=103,B=104,I=105,D=255;const{min:M}=Math,{defineProperty:v}=Object,{fromCharCode:E}=String,O=t=>{switch(t.getUint8(F++)){case w:return t.getUint8(F++);case h:{const n=t.getUint16(F,e);return F+=2,n}case b:{const n=t.getUint32(F,e);return F+=4,n}default:return(t=>{const n=t.getFloat64(F,e);return F+=8,n})(t)}},k=(t,w)=>{const h=F++;switch(t.getUint8(h)){case u:{const e=[];w.set(h,e);const n=O(t);for(let r=0;r<n;r++)e[r]=k(t,w);return e}case i:{const e={};w.set(h,e);const n=O(t);for(let r=0;r<n;r++){const n=k(t,w);n!==C&&(e[n]=k(t,w))}return e}case o:{const e=O(t),n=2*e,r=t.buffer.slice(F,F+n),s=new Uint16Array(r,0,e);let c="";for(let t=0;t<e;t+=32767){const n=M(t+32767,e);c+=E.apply(null,s.subarray(t,n))}return w.set(h,c),F+=n,c}case l:{const e=O(t),n=O(t),r=[e];n&&r.push({maxByteLength:n});const s=new ArrayBuffer(...r);return w.set(h,s),new Uint8Array(s).set(new Uint8Array(t.buffer,F,e)),F+=e,s}case f:{const e=k(t,w),n=O(t),r=O(t),s=[k(t,w),n];r&&s.push(r);const c=new globalThis[e](...s);return w.set(h,c),c}case m:{const e=new Date(O(t));return w.set(h,e),e}case S:{const e=O(t),n=new Map;w.set(h,n);for(let r=0;r<e;r++){const e=k(t,w);e!==C&&n.set(e,k(t,w))}return n}case A:{const e=O(t),n=new Set;w.set(h,n);for(let r=0;r<e;r++){const e=k(t,w);e!==C&&n.add(e)}return n}case B:{const e=k(t,w),n=k(t,w),r=new RegExp(e,n);return w.set(h,r),r}case I:{const e=globalThis[k(t,w)]||Error,n=k(t,w),r=k(t,w),s=new e(n);return w.set(h,v(s,"stack",{value:r})),s}case n:return w.get(O(t));case g:return t.getInt8(F++);case y:{const n=t.getInt16(F,e);return F+=2,n}case U:{const n=t.getInt32(F,e);return F+=4,n}case d:{const n=t.getFloat64(F,e);return F+=8,n}case p:{const n=t.getBigInt64(F,e);return F+=8,n}case s:return!0;case r:return!1;case c:return null;case a:return;case D:return C;case x:return(b=k(t,w)).startsWith("Symbol.")?Symbol[b.slice(b.indexOf(".")+1)]:Symbol.for(b);default:throw new Error(`Unknown type: ${t.getUint8(F-1)}`)}var b},C=Symbol();let F=0;const L=(t,{byteOffset:e=0}={})=>(F=e,k(new DataView(t),new Map)),T=t=>(e,n)=>L(n,t);export{L as decode,T as decoder};
