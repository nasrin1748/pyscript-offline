const e="",{toString:r}={},{keys:t}=Object,n=t=>{const n=typeof t;if("object"!==n||!t)return[0,n];const s=r.call(t).slice(8,-1);switch(s){case"Array":return[1,e];case"Object":return[2,e];case"Date":return[3,e];case"RegExp":return[4,e];case"Map":return[5,e];case"Set":return[6,e];case"DataView":return[1,s]}return s.includes("Array")?[1,s]:s.includes("Error")?[7,s]:[2,s]},s=([e,r])=>0===e&&("function"===r||"symbol"===r),c=(e,{json:r,lossy:c}={})=>{const o=[];return((e,r,c,o)=>{const a=(e,r)=>{const t=o.push(e)-1;return c.set(r,t),t},u=o=>{if(c.has(o))return c.get(o);let[i,f]=n(o);switch(i){case 0:{let r=o;switch(f){case"bigint":i=8,r=o.toString();break;case"function":case"symbol":if(e)throw new TypeError("unable to serialize "+f);r=null;break;case"undefined":return a([-1],o)}return a([i,r],o)}case 1:{if(f){let e=o;return"DataView"===f?e=new Uint8Array(o.buffer):"ArrayBuffer"===f&&(e=new Uint8Array(o)),a([f,[...e]],o)}const e=[],r=a([i,e],o);for(const r of o)e.push(u(r));return r}case 2:{if(f)switch(f){case"BigInt":return a([f,o.toString()],o);case"Boolean":case"Number":case"String":return a([f,o.valueOf()],o)}if(r&&"toJSON"in o)return u(o.toJSON());const c=[],l=a([i,c],o);for(const r of t(o))!e&&s(n(o[r]))||c.push([u(r),u(o[r])]);return l}case 3:return a([i,o.toISOString()],o);case 4:{const{source:e,flags:r}=o;return a([i,{source:e,flags:r}],o)}case 5:{const r=[],t=a([i,r],o);for(const[t,c]of o)(e||!s(n(t))&&!s(n(c)))&&r.push([u(t),u(c)]);return t}case 6:{const r=[],t=a([i,r],o);for(const t of o)!e&&s(n(t))||r.push(u(t));return t}}const{message:l}=o;return a([i,{name:f,message:l}],o)};return u})(!(r||c),!!r,new Map,o)(e),o},{stringify:o}=JSON,a={json:!0,lossy:!0},u=e=>o(c(e,a));const i=e=>u(e),f=(e=>({byteOffset:r=0}={})=>(t,n)=>{const s=e(t),c=s.length,o=2*c+r;n.byteLength<o&&n.grow(o);const a=new Uint16Array(n,r,c);for(let e=0;e<c;e++)a[e]=s.charCodeAt(e);return c})(u);export{i as encode,f as encoder};
