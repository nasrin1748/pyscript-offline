const e=Promise.withResolvers.bind(Promise);const{create:t}=Object;let r="coincident-",n=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),r+=crypto.randomUUID()}catch(e){n=!1,r+=Math.random().toString(36).substring(2)}const s=2*Int32Array.BYTES_PER_ELEMENT,a=32767,o={byteOffset:s,useUTF16:!0,circular:!0},c=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n};var u=256===new DataView(new Uint16Array([256]).buffer).getUint16(0,!0),i=0,l=1,f=2,g=3,w=4,y=5,p=10,d=20,h=30,m=40,b=50,U=51,v=52,S=53,A=54,B=55,M=64,E=70,x=100,I=101,L=102,P=103,D=104,O=105,T=255;const{min:R}=Math,{defineProperty:j}=Object,{fromCharCode:k}=String,F=e=>{switch(e.getUint8(W++)){case U:return e.getUint8(W++);case S:{const t=e.getUint16(W,u);return W+=2,t}case B:{const t=e.getUint32(W,u);return W+=4,t}default:return(e=>{const t=e.getFloat64(W,u);return W+=8,t})(e)}},C=(e,t)=>{const r=W++;switch(e.getUint8(r)){case p:{const n=[];t.set(r,n);const s=F(e);for(let r=0;r<s;r++)n[r]=C(e,t);return n}case d:{const n={};t.set(r,n);const s=F(e);for(let r=0;r<s;r++){const r=C(e,t);r!==V&&(n[r]=C(e,t))}return n}case y:{const n=F(e),s=2*n,o=e.buffer.slice(W,W+s),c=new Uint16Array(o,0,n);let u="";for(let e=0;e<n;e+=a){const t=R(e+a,n);u+=k.apply(null,c.subarray(e,t))}return t.set(r,u),W+=s,u}case h:{const n=F(e),s=F(e),a=[n];s&&a.push({maxByteLength:s});const o=new ArrayBuffer(...a);return t.set(r,o),new Uint8Array(o).set(new Uint8Array(e.buffer,W,n)),W+=n,o}case m:{const n=C(e,t),s=F(e),a=F(e),o=[C(e,t),s];a&&o.push(a);const c=new globalThis[n](...o);return t.set(r,c),c}case x:{const n=new Date(F(e));return t.set(r,n),n}case I:{const n=F(e),s=new Map;t.set(r,s);for(let r=0;r<n;r++){const r=C(e,t);r!==V&&s.set(r,C(e,t))}return s}case L:{const n=F(e),s=new Set;t.set(r,s);for(let r=0;r<n;r++){const r=C(e,t);r!==V&&s.add(r)}return s}case D:{const n=C(e,t),s=C(e,t),a=new RegExp(n,s);return t.set(r,a),a}case O:{const n=globalThis[C(e,t)]||Error,s=C(e,t),a=C(e,t),o=new n(s);return t.set(r,j(o,"stack",{value:a})),o}case i:return t.get(F(e));case b:return e.getInt8(W++);case v:{const t=e.getInt16(W,u);return W+=2,t}case A:{const t=e.getInt32(W,u);return W+=4,t}case M:{const t=e.getFloat64(W,u);return W+=8,t}case E:{const t=e.getBigInt64(W,u);return W+=8,t}case f:return!0;case l:return!1;case g:return null;case w:return;case T:return V;case P:return(n=C(e,t)).startsWith("Symbol.")?Symbol[n.slice(n.indexOf(".")+1)]:Symbol.for(n);default:throw new Error(`Unknown type: ${e.getUint8(W-1)}`)}var n},V=Symbol();let W=0;const _=e=>(t,r)=>((e,{byteOffset:t=0}={})=>(W=t,C(new DataView(e),new Map)))(r,e),N=[],Y=new WeakSet,$=(...e)=>(Y.add(e),e),q=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),q.resolve([e.data,e.ports[0]])}),{once:!0});var z=async r=>{const[s,u]=await q.promise,i=n&&!!s,l=r?.transform,f=(r?.decoder||_)(o),g=!1!==r?.transfer;let w,y,p;if(n){const e=new SharedArrayBuffer(r?.minByteLength||a,{maxByteLength:r?.maxByteLength||16777216});w=new Int32Array(e),({pause:y,wait:p}=Atomics),!y||i||e instanceof ArrayBuffer||(p=(e,t)=>{for(;e[t]<1;)y()})}const[d,h]=((t=e=>e)=>{const r=new Map;let n=0;return[()=>{let s;do{s=t(n++)}while(r.has(s));const a=e();return r.set(s,a),[s,a.promise]},(e,t,n)=>{const s=r.get(e);r.delete(e),n?s?.reject(n):s?.resolve(t)}]})(String),m=new Map,b=t(null),U=new Proxy(b,{get(e,t){if("then"===t)return;let r=m.get(t);return r||m.set(t,r=(...e)=>{const r=((e,t)=>{let r=N;return e&&Y.has(t.at(-1)||N)&&(r=t.pop(),Y.delete(r)),r})(g,e),a=[w,t,l?e.map(l):e];if(n){i?postMessage({ID:s,data:a},r):u.postMessage(a,r),p(w,0),w[0]=0;const e=w[1]?f(w[1],w.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=d();return a[0]=e,u.postMessage(a,r),t}}),r},set:c});return u.onmessage=async({data:e})=>{"string"==typeof e[0]?h.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,b,l),u.postMessage(e))},{native:n,proxy:U,transfer:$}};export{z as default};
