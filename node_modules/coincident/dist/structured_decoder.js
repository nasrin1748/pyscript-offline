const e="object"==typeof self?self:globalThis,t=t=>((t,r)=>{const n=(e,r)=>(t.set(r,e),e),s=a=>{if(t.has(a))return t.get(a);const[c,o]=r[a];switch(c){case 0:case-1:return n(o,a);case 1:{const e=n([],a);for(const t of o)e.push(s(t));return e}case 2:{const e=n({},a);for(const[t,r]of o)e[s(t)]=s(r);return e}case 3:return n(new Date(o),a);case 4:{const{source:e,flags:t}=o;return n(new RegExp(e,t),a)}case 5:{const e=n(new Map,a);for(const[t,r]of o)e.set(s(t),s(r));return e}case 6:{const e=n(new Set,a);for(const t of o)e.add(s(t));return e}case 7:{const{name:t,message:r}=o;return n(new e[t](r),a)}case 8:return n(BigInt(o),a);case"BigInt":return n(Object(BigInt(o)),a);case"ArrayBuffer":return n(new Uint8Array(o).buffer,o);case"DataView":{const{buffer:e}=new Uint8Array(o);return n(new DataView(e),o)}}return n(new e[c](o),a)};return s})(new Map,t)(0)
/*! (c) Andrea Giammarchi - ISC */,{parse:r}=JSON,n=e=>t(r(e));let s="coincident-";try{new SharedArrayBuffer(4,{maxByteLength:8}),s+=crypto.randomUUID()}catch(e){s+=Math.random().toString(36).substring(2)}const{fromCharCode:a}=String,{min:c}=Math;const o=e=>n(e),f=(e=>({byteOffset:t=0}={})=>(r,n)=>{const s=new Uint16Array(n,t,r);let o="",f=0;for(;f<r;){const e=c(f+32767,r);o+=a.apply(null,s.subarray(f,e)),f=e}return e(o)})(n);export{o as decode,f as decoder};
