const e="940beb37",t="="+e,r="-"+e,{create:n}=Object;let s="coincident-",a=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),s+=crypto.randomUUID()}catch(e){a=!1,s+=Math.random().toString(36).substring(2)}const o=2*Int32Array.BYTES_PER_ELEMENT,c={byteOffset:o,useUTF16:!0,circular:!0},l=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n},{fromCharCode:i}=String,{min:u}=Math;var f=e=>({byteOffset:t=0}={})=>(r,n)=>{const s=new Uint16Array(n,t,r);let a="",o=0;for(;o<r;){const e=u(o+32767,r);a+=i.apply(null,s.subarray(o,e)),o=e}return e(a)};const{parse:y}=JSON,p=f(y),d="array",g="bigint",h="boolean",w="function",b="null",m="number",v="object",E="string",P="symbol",O="undefined";var S={[d]:0,[g]:1,[h]:2,[w]:3,[b]:4,[m]:5,[v]:6,[E]:7,[P]:8,[O]:9,view:10};const{parse:T}=JSON,R=f((e=>{const t=T(e);switch(t[0]){case S.view:{const[e,r]=t[1],n=new Uint8Array(r);t[1]=new globalThis[e](n.buffer);break}case S[O]:t[1]=void 0;break;case S[g]:t[1]=BigInt(t[1])}return t})),x=Promise.withResolvers.bind(Promise);const _=[],A=new WeakSet,k=(...e)=>(A.add(e),e),M=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),M.resolve([e.data,e.ports[0]])}),{once:!0});var I=async e=>{const[t,r]=await M.promise,s=a&&!!t,o=e?.transform,i=(e?.decoder||p)(c),u=!1!==e?.transfer;let f,y,d;if(a){const t=new SharedArrayBuffer(e?.minByteLength||32767,{maxByteLength:e?.maxByteLength||16777216});f=new Int32Array(t),({pause:y,wait:d}=Atomics),!y||s||t instanceof ArrayBuffer||(d=(e,t)=>{for(;e[t]<1;)y()})}const[g,h]=((e=e=>e)=>{const t=new Map;let r=0;return[()=>{let n;do{n=e(r++)}while(t.has(n));const s=x();return t.set(n,s),[n,s.promise]},(e,r,n)=>{const s=t.get(e);t.delete(e),n?s?.reject(n):s?.resolve(r)}]})(String),w=new Map,b=n(null),m=new Proxy(b,{get(e,n){if("then"===n)return;let c=w.get(n);return c||w.set(n,c=(...e)=>{const c=((e,t)=>{let r=_;return e&&A.has(t.at(-1)||_)&&(r=t.pop(),A.delete(r)),r})(u,e),l=[f,n,o?e.map(o):e];if(a){s?postMessage({ID:t,data:l},c):r.postMessage(l,c),d(f,0),f[0]=0;const e=f[1]?i(f[1],f.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=g();return l[0]=e,r.postMessage(l,c),t}}),c},set:l});return r.onmessage=async({data:e})=>{"string"==typeof e[0]?h.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,b,o),r.postMessage(e))},{native:a,proxy:m,transfer:k}};const B="apply",N="construct",L="defineProperty",j="deleteProperty",Y="get",D="getOwnPropertyDescriptor",F="getPrototypeOf",U="has",W="isExtensible",C="ownKeys",$="preventExtensions",K="set",G="setPrototypeOf";var z=Object.freeze({__proto__:null,APPLY:B,CONSTRUCT:N,DEFINE_PROPERTY:L,DELETE_PROPERTY:j,GET:Y,GET_OWN_PROPERTY_DESCRIPTOR:D,GET_PROTOTYPE_OF:F,HAS:U,IS_EXTENSIBLE:W,OWN_KEYS:C,PREVENT_EXTENSION:$,SET:K,SET_PROTOTYPE_OF:G});const J="destruct";function V(){return this}const X=new FinalizationRegistry((([e,t,r])=>{r&&console.debug(`%c${String(t)}`,"font-weight:bold","collected"),e(t)})),H=Object.create(null),{Object:q,Proxy:Q,Reflect:Z}=globalThis,{isArray:ee}=Array,{ownKeys:te}=Z,{create:re,hasOwn:ne,values:se}=q,ae=(e,t)=>t===d?e[0]:t===w?e():t===v?e.$:e,oe=(e,t,r,n)=>{const s={type:{value:t}},a=ne(e,"valueOf");for(const o of se(z)){let c=n(e[o]||Z[o]);if(a&&o===Y){const{valueOf:n}=e,{value:s}=c;c={value(e,a,...o){return a===r?n.call(this,ae(e,t)):s.call(this,e,a,...o)}}}s[o]=c}return re(e,s)},ce=(e,t,r,n=e)=>{if(n===e)switch(typeof e){case v:case O:n||(n=!1);case w:break;default:n=!1,t===e&&(t=q(e))}const s=new Q(t,r),{destruct:a}=r;return a?((e,t,{debug:r,handler:n,return:s,token:a=e}=H)=>{const o=s||new Proxy(e,n||H),c=[o,[t,e,!!r]];return!1!==a&&c.push(a),X.register(...c),o})(e,a,{token:n,return:s}):s},le=e=>t=>{const r=typeof t;return r===v?t?e.get(t)?.[0]??(e=>ee(e)?d:v)(t):b:r},ie=e=>t=>{let r=typeof t;switch(r){case v:if(!t){r=b;break}case w:const n=e.get(t);n&&([r,t]=n)}return[r,t]},ue=e=>((e=>{X.unregister(e)})(e),e);var fe=e=>{const t=new WeakMap,r=Symbol(),n={},s=(e,r,n)=>(t.set(e,[r,n]),e),a={proxy:n,release:ue,pair:ie(t),typeOf:le(t),isProxy:e=>t.has(e),valueOf:e=>e[r]??e.valueOf()};for(const t of te(e)){if(ne(a,t))continue;const o=e[t];switch(t){case d:{const e=oe(o,t,r,(e=>({value([t],...r){return e.call(this,t,...r)}})));n[t]=(t,...r)=>s(ce(t,[t],e,...r),d,t);break}case w:{const e=oe(o,t,r,(e=>({value(t,...r){return e.call(this,t(),...r)}})));n[t]=(t,...r)=>{return s(ce(t,(n=t,V.bind(n)),e,...r),w,t);var n};break}case v:{const e=oe(o,t,r,(e=>({value({$:t},...r){return e.call(this,t,...r)}})));n[t]=(t,...r)=>s(ce(t,{$:t},e,...r),v,t);break}default:{const e=oe(o,t,r,(e=>({value:e})));n[t]=(r,...n)=>s(ce(r,r,e,...n),t,r);break}}}return a};const{drop:ye,get:pe,hold:de}=(()=>{const e=new Map,t=new Map;let r=0;return{clear:()=>{e.clear(),t.clear()},drop:r=>{const[n,s]=typeof r===m?[t,e]:[e,t],a=n.has(r);return a&&(s.delete(n.get(r)),n.delete(r)),a},get:e=>t.get(e),hold:n=>{if(!e.has(n)){let s;for(;t.has(s=r++););e.set(n,s),t.set(s,n)}return e.get(n)}}})(),ge=new Map;for(const e of Reflect.ownKeys(Symbol))typeof Symbol[e]===P&&(ge.set(Symbol[e],e),ge.set(e,Symbol[e]));const he=e=>ge.get(e)||`.${Symbol.keyFor(e)||""}`,{isArray:we}=Array,{isView:be}=ArrayBuffer,{[B]:me}=Reflect;var ve=(e,t)=>{const r=new Map,n=(e,t)=>{let n=r.get(e)?.deref();return n||r.set(e,new WeakRef(n=t(e))),n},s=([e,t])=>{switch(e){case S[v]:return null==t?globalThis:typeof t===m?n(t,i.object):t;case S[d]:return typeof t===m?n(t,i.array):t;case S[w]:return typeof t===m?n(t,i.function):pe(parseInt(t));case S[P]:return(e=>ge.get(e)||Symbol.for(e.slice(1)))(t);default:return t}},a=e=>{let[r,n]=f(e);switch(r){case v:if(n==globalThis||null==n)n=null;else if(typeof n===v){if(n=t(n),we(n))return[S[d],n.map(a)];if(be(n))return[S.view,n];{const e={};for(const t in n)e[t]=a(n[t]);n=e}}return[S[v],n];case d:return[S[d],typeof n===m?n:t(n).map(a)];case w:return[S[w],typeof n===w?String(de(t(n))):n];case P:return[S[P],he(e)];default:return[S[r],n]}},o=(...t)=>s(e(...t)),c={[L]:(e,t,r)=>o(L,e,a(t),a(r)),[j]:(e,t)=>o(j,e,a(t)),[Y]:(e,t)=>o(Y,e,a(t)),[F]:e=>o(F,e),[D]:(e,t)=>{const r=o(D,e,a(t));if(r){const{get:e,set:t,value:n}=r;e&&(r.get=s(e)),t&&(r.set=s(t)),n&&(r.value=s(n))}return r},[U]:(e,t)=>o(U,e,a(t)),[W]:e=>o(W,e),[C]:e=>o(C,e).map(s),[$]:e=>o($,e),[K]:(e,t,r)=>o(K,e,a(t),a(r)),[G]:(e,t)=>o(G,e,a(t)),[J](t){r.delete(t),e(J,t)}},l={[v]:c,[d]:c,[w]:{...c,[B]:(e,...t)=>o(B,e,...t.map(a)),[N]:(e,...t)=>o(N,e,...t.map(a))}},{proxy:i,isProxy:u,pair:f}=fe(l);return{isProxy:u,global:i.object(null),method:async(e,t,...r)=>{const n=parseInt(t);switch(e){case B:{const[e,t]=r;return a(await me(pe(n),s(e),t.map(s)))}case J:ye(n)}}}},Ee=async e=>{let n=!1;const s=e?.decoder||p,a=await I({...e,decoder(e){const t=s(e),r=R(e);return(e,s)=>n?(n=!1,r(e,s)):t(e,s)}}),o=a.proxy[t],{isProxy:c,global:l,method:i}=ve((function(...e){return n=!0,o.apply(this,e)}),e?.transform||(e=>e));return a.proxy[r]=i,{...a,window:l,isWindowProxy:c}};export{Ee as default};
