const e=Promise.withResolvers.bind(Promise);const t="object"==typeof self?self:globalThis,r=e=>((e,r)=>{const n=(t,r)=>(e.set(r,t),t),s=a=>{if(e.has(a))return e.get(a);const[o,c]=r[a];switch(o){case 0:case-1:return n(c,a);case 1:{const e=n([],a);for(const t of c)e.push(s(t));return e}case 2:{const e=n({},a);for(const[t,r]of c)e[s(t)]=s(r);return e}case 3:return n(new Date(c),a);case 4:{const{source:e,flags:t}=c;return n(new RegExp(e,t),a)}case 5:{const e=n(new Map,a);for(const[t,r]of c)e.set(s(t),s(r));return e}case 6:{const e=n(new Set,a);for(const t of c)e.add(s(t));return e}case 7:{const{name:e,message:r}=c;return n(new t[e](r),a)}case 8:return n(BigInt(c),a);case"BigInt":return n(Object(BigInt(c)),a);case"ArrayBuffer":return n(new Uint8Array(c).buffer,c);case"DataView":{const{buffer:e}=new Uint8Array(c);return n(new DataView(e),c)}}return n(new t[o](c),a)};return s})(new Map,e)(0)
/*! (c) Andrea Giammarchi - ISC */,{parse:n}=JSON,{create:s}=Object;let a="coincident-",o=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),a+=crypto.randomUUID()}catch(e){o=!1,a+=Math.random().toString(36).substring(2)}const c=2*Int32Array.BYTES_PER_ELEMENT,f={byteOffset:c,useUTF16:!0,circular:!0},i=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n},{fromCharCode:u}=String,{min:l}=Math;const p=(w=e=>r(n(e)),({byteOffset:e=0}={})=>(t,r)=>{const n=new Uint16Array(r,e,t);let s="",a=0;for(;a<t;){const e=l(a+32767,t);s+=u.apply(null,n.subarray(a,e)),a=e}return w(s)});var w;const y=[],g=new WeakSet,d=(...e)=>(g.add(e),e),h=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),h.resolve([e.data,e.ports[0]])}),{once:!0});var m=async t=>{const[r,n]=await h.promise,a=o&&!!r,c=t?.transform,u=(t?.decoder||p)(f),l=!1!==t?.transfer;let w,m,b;if(o){const e=new SharedArrayBuffer(t?.minByteLength||32767,{maxByteLength:t?.maxByteLength||16777216});w=new Int32Array(e),({pause:m,wait:b}=Atomics),!m||a||e instanceof ArrayBuffer||(b=(e,t)=>{for(;e[t]<1;)m()})}const[B,M]=((t=e=>e)=>{const r=new Map;let n=0;return[()=>{let s;do{s=t(n++)}while(r.has(s));const a=e();return r.set(s,a),[s,a.promise]},(e,t,n)=>{const s=r.get(e);r.delete(e),n?s?.reject(n):s?.resolve(t)}]})(String),v=new Map,A=s(null),S=new Proxy(A,{get(e,t){if("then"===t)return;let s=v.get(t);return s||v.set(t,s=(...e)=>{const s=((e,t)=>{let r=y;return e&&g.has(t.at(-1)||y)&&(r=t.pop(),g.delete(r)),r})(l,e),f=[w,t,c?e.map(c):e];if(o){a?postMessage({ID:r,data:f},s):n.postMessage(f,s),b(w,0),w[0]=0;const e=w[1]?u(w[1],w.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=B();return f[0]=e,n.postMessage(f,s),t}}),s},set:i});return n.onmessage=async({data:e})=>{"string"==typeof e[0]?M.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,A,c),n.postMessage(e))},{native:o,proxy:S,transfer:d}};export{m as default};
