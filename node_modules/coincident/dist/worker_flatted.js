const e=Promise.withResolvers.bind(Promise);const{create:t}=Object;let r="coincident-",n=!0;try{new SharedArrayBuffer(4,{maxByteLength:8}),r+=crypto.randomUUID()}catch(e){n=!1,r+=Math.random().toString(36).substring(2)}const s=2*Int32Array.BYTES_PER_ELEMENT,a={byteOffset:s,useUTF16:!0,circular:!0},o=(e,t,r)=>{const n="then"!==t;return n&&(e[t]=r),n},{fromCharCode:c}=String,{min:u}=Math;var l=0,i=1,f=2,p=3,y=4,d=5,h=6,w=7,g=8,m=9,v=10,b=11,S=12,B=13,E=14,M=15,x=16,A=17;const{defineProperty:L}=Object,P=e=>{switch(e[O++]){case i:{const t=e[O++],r=[];e[O-2]=r;for(let n=0;n<t;n++)r[n]=P(e);return r}case f:{const t=e[O++],r={};e[O-2]=r;for(let n=0;n<t;n++)r[P(e)]=P(e);return r}case y:{const t=e[O++];return e[O-2]=t,t}case p:return e[O++];case d:return!0;case h:return!1;case w:return null;case B:return;case S:return BigInt(e[O++]);case g:{const t=e[O++],r=e[O++],n=[t];r&&n.push({maxByteLength:r});const s=new ArrayBuffer(...n);e[O-3]=s;const a=new Uint8Array(s,0,t);for(let r=0;r<t;r++)a[r]=e[O++];return s}case m:{const t=e[O++],r=e[O++],n=e[O++],s=O-4,a=[P(e),r];n&&a.push(n);const o=new globalThis[t](...a);return e[s]=o,o}case b:{const t=new Date(e[O++]);return e[O-2]=t,t}case E:{const t=e[O++],r=new Map;e[O-2]=r;for(let n=0;n<t;n++){const t=P(e),n=P(e);void 0!==t&&r.set(t,n)}return r}case M:{const t=e[O++],r=new Set;e[O-2]=r;for(let n=0;n<t;n++){const t=P(e);void 0!==t&&r.add(t)}return r}case x:{const t=e[O++],r=e[O++],n=new RegExp(t,r);return e[O-3]=n,n}case A:{const t=globalThis[e[O++]]||Error,r=e[O++],n=e[O++],s=new t(r,{cause:e[O++]});return e[O-5]=L(s,"stack",{value:n}),s}case v:return(t=e[O++]).startsWith("Symbol.")?Symbol[t.slice(t.indexOf(".")+1)]:Symbol.for(t);case l:return e[e[O++]];default:throw new TypeError(`Unknown type: ${e[O-1]}`)}var t},{parse:I}=JSON;let O=0;const T=(e=>({byteOffset:t=0}={})=>(r,n)=>{const s=new Uint16Array(n,t,r);let a="",o=0;for(;o<r;){const e=u(o+32767,r);a+=c.apply(null,s.subarray(o,e)),o=e}return e(a)})((e=>{return t=I(e),O=0,t.length?P(t):void 0;var t})),U=[],D=new WeakSet,R=(...e)=>(D.add(e),e),j=Promise.withResolvers();addEventListener("message",(e=>{(e=>{e.stopImmediatePropagation(),e.preventDefault()})(e),j.resolve([e.data,e.ports[0]])}),{once:!0});var k=async r=>{const[s,c]=await j.promise,u=n&&!!s,l=r?.transform,i=(r?.decoder||T)(a),f=!1!==r?.transfer;let p,y,d;if(n){const e=new SharedArrayBuffer(r?.minByteLength||32767,{maxByteLength:r?.maxByteLength||16777216});p=new Int32Array(e),({pause:y,wait:d}=Atomics),!y||u||e instanceof ArrayBuffer||(d=(e,t)=>{for(;e[t]<1;)y()})}const[h,w]=((t=e=>e)=>{const r=new Map;let n=0;return[()=>{let s;do{s=t(n++)}while(r.has(s));const a=e();return r.set(s,a),[s,a.promise]},(e,t,n)=>{const s=r.get(e);r.delete(e),n?s?.reject(n):s?.resolve(t)}]})(String),g=new Map,m=t(null),v=new Proxy(m,{get(e,t){if("then"===t)return;let r=g.get(t);return r||g.set(t,r=(...e)=>{const r=((e,t)=>{let r=U;return e&&D.has(t.at(-1)||U)&&(r=t.pop(),D.delete(r)),r})(f,e),a=[p,t,l?e.map(l):e];if(n){u?postMessage({ID:s,data:a},r):c.postMessage(a,r),d(p,0),p[0]=0;const e=p[1]?i(p[1],p.buffer):void 0;if(e instanceof Error)throw e;return e}{const[e,t]=h();return a[0]=e,c.postMessage(a,r),t}}),r},set:o});return c.onmessage=async({data:e})=>{"string"==typeof e[0]?w.apply(null,e):(await(async(e,t,r)=>{try{const n=await t[e[1]].apply(null,e[2]);e[1]=r?r(n):n,e[2]=null}catch(t){e[2]=t}})(e,m,l),c.postMessage(e))},{native:n,proxy:v,transfer:R}};export{k as default};
